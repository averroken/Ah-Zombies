{"version":3,"sources":["room_1.js"],"names":["TopDownGame","result","room_1","prototype","create","this","createMap","map","addTilesetImage","backgroundlayer","createLayer","blockedLayer","setCollisionBetween","resizeWorld","count","findSpawnPoint","position","player","game","add","sprite","x","y","id","Player","Id","console","log","socket","emit","Map","velocity","physics","arcade","enable","camera","follow","cursors","input","keyboard","createCursorKeys","scale","fullScreenScaleMode","Phaser","ScaleManager","EXACT_FIT","onDown","gofull","createItems","createDoors","isFullScreen","stopFullScreen","startFullScreen","tilemap","items","group","enableBody","length","findObjectsByType","key","forEach","element","createFromTiledObject","doors","type","layer","spawnPosition","Array","objects","offset","undefined","properties","spawnPoint","tileHeight","push","Object","keys","collect","collectable","destroy","index","indexOf","splice","enterDoor","door","targetRoom","targetTileMap","split","state","start","states","update","boolMoved","body","up","isDown","down","left","right","collide","overlap"],"mappings":"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","file":"room_1.js","sourcesContent":["'use strict';\n\nvar TopDownGame = TopDownGame || {};\nvar result;\n\nTopDownGame.room_1 = function () {};\n\nTopDownGame.room_1.prototype = {\n    create: function create() {\n        this.createMap();\n        this.map.addTilesetImage('cute_lpc', 'dungeonTiles');\n        this.backgroundlayer = this.map.createLayer('backgroundLayer');\n        this.blockedLayer = this.map.createLayer('blockedLayer');\n\n        this.map.setCollisionBetween(1, 2000, true, 'blockedLayer');\n\n        this.backgroundlayer.resizeWorld();\n\n        this.count = 0;\n\n        // var result = this.findObjectsByType('playerStart', this.map, 'objectsLayer');\n        result = this.findSpawnPoint('playerStart', this.map, 'objectsLayer', this.position);\n\n        this.player = this.game.add.sprite(result[0].x, result[0].y, 'player');\n        this.player.id = Player.Id;\n        console.log(\"My id: \" + Player.Id);\n\n        socket.emit('getPlayers');\n\n        console.log(Player.Map);\n\n        socket.emit(\"moveMyPlayer\", {\n            id: this.player.id,\n            x: this.player.x,\n            y: this.player.y,\n            map: Player.Map\n        });\n        this.player.velocity = 75;\n\n        this.game.physics.arcade.enable(this.player);\n\n        this.game.camera.follow(this.player);\n\n        this.cursors = this.game.input.keyboard.createCursorKeys();\n\n        this.game.scale.fullScreenScaleMode = Phaser.ScaleManager.EXACT_FIT;\n        this.game.input.onDown.add(this.gofull, this);\n\n        this.createItems();\n        this.createDoors();\n    },\n    gofull: function gofull() {\n        if (this.game.scale.isFullScreen) {\n            this.game.scale.stopFullScreen();\n        } else {\n            this.game.scale.startFullScreen(false);\n        }\n    },\n    createMap: function createMap() {\n        this.map = this.game.add.tilemap('room_1');\n        if (!this.position) this.position = \"down\";\n    },\n    createItems: function createItems() {\n        console.log(this.map);\n        this.items = this.game.add.group();\n        this.items.enableBody = true;\n        var item;\n        console.log(items.length);\n        if (!(items.length >= 0)) {\n            console.log(\"length new: :\" + items.length);\n            result = this.findObjectsByType('item', this.map, 'objectsLayer');\n            items = result;\n            socket.emit(\"setItemList\", items, this.map.key);\n        } else console.log(items.length);\n        console.log(this.items.length);\n        items.forEach(function (element) {\n            this.createFromTiledObject(element, this.items);\n        }, this);\n        console.log(this.items.length);\n    },\n    createDoors: function createDoors() {\n        this.doors = this.game.add.group();\n        this.doors.enableBody = true;\n        result = this.findObjectsByType('door', this.map, 'objectsLayer');\n\n        result.forEach(function (element) {\n            this.createFromTiledObject(element, this.doors);\n        }, this);\n    },\n    findSpawnPoint: function findSpawnPoint(type, map, layer, spawnPosition) {\n        var result = new Array();\n        if (result.length < 0) return;\n        map.objects[layer].forEach(function (element) {\n            var offset = 0;\n            if (element.properties.offset != undefined) {\n                offset = element.properties.offset;\n            }\n            if (element.properties.spawnPoint === spawnPosition) {\n                console.log(\"-------> spawn point found\");\n            } else {\n                console.log(\"-------> spawn NOT point found --------------\");\n                return;\n            }\n            if (element.properties.type === type) {\n                element.y -= map.tileHeight + 45 + offset;\n                result.push(element);\n            }\n        });\n        return result;\n    },\n    findObjectsByType: function findObjectsByType(type, map, layer) {\n        var result = new Array();\n        if (result.length < 0) return;\n        map.objects[layer].forEach(function (element) {\n            var offset = 0;\n            if (element.properties.offset != undefined) {\n                offset = element.properties.offset;\n            }\n            if (element.properties.type === type) {\n                element.y -= map.tileHeight + 45 + offset;\n                result.push(element);\n            }\n        });\n        return result;\n    },\n    createFromTiledObject: function createFromTiledObject(element, group) {\n        var sprite = group.create(element.x, element.y, element.properties.sprite);\n\n        Object.keys(element.properties).forEach(function (key) {\n            sprite[key] = element.properties[key];\n        });\n    },\n    collect: function collect(player, collectable) {\n        console.log(this.map);\n        var Map = this.map;\n        if (collectable.sprite == 'bluecup' || collectable.sprite == 'greencup') {\n            player.velocity = 100;\n        }\n        collectable.destroy();\n        items.forEach(function (element) {\n            if (element.x === collectable.position.x && element.y === collectable.position.y) {\n                var index = items.indexOf(element);\n                items.splice(index, 1);\n                console.log(items.length);\n                console.log(Map.key);\n                socket.emit(\"updateItemList\", items, Map.key);\n            }\n        });\n        // socket.emit(\"updateItemList\", items);\n    },\n    enterDoor: function enterDoor(player, door) {\n        var targetRoom = door.targetTileMap.split('|');\n        console.log('entering the door');\n        console.log('targetTileMap: ' + targetRoom[0]);\n        socket.emit('changeMap', targetRoom[0], Player.Id);\n        TopDownGame.game.state.start(targetRoom[0]);\n        console.log('entering the door');\n        console.log('targetTileMap: ' + targetRoom[0]);\n        console.log('targetSpawnPoint: ' + targetRoom[1]);\n\n        if (targetRoom[0] !== \"mini_game\") TopDownGame.game.state.states[targetRoom[0]].position = targetRoom[1];\n        TopDownGame.game.state.start(targetRoom[0]);\n    },\n    update: function update() {\n        // console.log(this.count);\n        var boolMoved = false;\n        this.player.body.velocity.y = 0;\n        this.player.body.velocity.x = 0;\n\n        if (this.cursors.up.isDown) {\n            this.player.body.velocity.y -= this.player.velocity;\n            boolMoved = true;\n        } else if (this.cursors.down.isDown) {\n            this.player.body.velocity.y += this.player.velocity;\n            boolMoved = true;\n        }\n        if (this.cursors.left.isDown) {\n            this.player.body.velocity.x -= this.player.velocity;\n            boolMoved = true;\n        } else if (this.cursors.right.isDown) {\n            this.player.body.velocity.x += this.player.velocity;\n            boolMoved = true;\n        }\n\n        this.game.physics.arcade.collide(this.player, this.blockedLayer);\n        this.game.physics.arcade.overlap(this.player, this.items, this.collect, null, this);\n        this.game.physics.arcade.overlap(this.player, this.doors, this.enterDoor, null, this);\n        if (boolMoved) {\n            this.count++;\n            if (this.count % 2 == 0) {\n                // console.log(this.count);\n                socket.emit(\"moveMyPlayer\", {\n                    id: this.player.id,\n                    x: this.player.x,\n                    y: this.player.y,\n                    map: Player.Map\n                });\n            }\n        }\n    }\n};"]}